#!/usr/bin/env python

import sys
import tempfile

import pyenv


def worker():
    all_actions = pyenv.Actions.get_all_actions()

    try:
        pyenv.options.TopLevelOptions.parse(sys.argv[1:], all_actions, pyenv.shell_mapper.keys())
    except pyenv.OptionParsingError as e:
        # no shell at this point, so we've already dumped everything to stderr.  just reraise.
        raise

    # set up module database.
    mdb = pyenv.ModuleDatabase()

    # figure out which shell...
    shell = pyenv.shell_mapper[pyenv.options.TopLevelOptions.shell]()

    env = pyenv.Environment(shell, mdb)

    action_requested = pyenv.options.TopLevelOptions.action
    action_arguments = pyenv.options.TopLevelOptions.action_options

    assert(action_requested in all_actions)
    action_processor = all_actions[action_requested]
    try:
        action_processor(action_requested, action_arguments, env, shell, mdb)
    except pyenv.OptionParsingError as e:
        # we have a shell, so just clean up normally.
        pass

    env.shutdown()

    wlog = pyenv.WarningLog.get_logger()

    for log_msg in wlog.get_log():
        shell.write("%s\n" % log_msg)

    shell_state = shell.dump_state()

    if (pyenv.options.TopLevelOptions.dump):
        sys.stderr.write("\n".join(shell_state) + "\n")

    return shell_state



def main():
    name = None
    try:
        shell_state = worker()

        # write this to a temp file.
        tfh = tempfile.NamedTemporaryFile(delete=False)
        tfh.write("\n".join(shell_state) + "\n")
        name = tfh.name
        tfh.close()
    except pyenv.OptionParsingError as e:
        # ignore the error if it gets this far up.
        pass
    finally:
        # write the name of the temp file to the shell.
        if (name is not None):
            sys.stdout.write("%s\n" % name)

if __name__ == "__main__":
    main()
