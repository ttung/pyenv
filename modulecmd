#!/usr/bin/env python

import sys
import tempfile

import pyenv


def worker():
    all_actions = pyenv.Actions.get_all_actions()

    try:
        pyenv.options.TopLevelOptions.parse(sys.argv[1:], all_actions, pyenv.shell_mapper.keys())
    except pyenv.OptionParsingError as e:
        # no shell at this point, so we've already dumped everything to stderr.  just reraise.
        raise

    # TODO: set up a better module database, based on PYENV_PATH
    mdb = pyenv.ModuleDatabase()

    # figure out which shell...
    shell = pyenv.shell_mapper[pyenv.options.TopLevelOptions.shell]()

    env = pyenv.Environment(shell, mdb)

    action_requested = pyenv.options.TopLevelOptions.action
    action_arguments = pyenv.options.TopLevelOptions.action_options

    assert(action_requested in all_actions)
    action_processor = all_actions[action_requested]
    try:
        action_processor(action_requested, action_arguments, env, shell, mdb)
    except pyenv.OptionParsingError as e:
        # we have a shell, so just clean up normally.
        pass

    env.shutdown()

    wlog = pyenv.WarningLog.get_logger()

    for log_msg in wlog.get_log():
        shell.message(log_msg)

    return shell.dump_state()



def main():
    try:
        shell_state = worker()

        # TODO: write this to a temp file.
        sys.stdout.write("\n".join(shell_state) + "\n")
    except pyenv.OptionParsingError as e:
        # ignore the error if it gets this far up.
        pass
    finally:
        # TODO: write the name of the temp file to the shell.
        pass

if __name__ == "__main__":
    main()
